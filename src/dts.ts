import * as dom from 'dts-dom';
import { check, clone, contains } from 'typed-json-transform';

export interface Options {
    tree: any,
    schema?: any,
    namespace: string
}

const recur = (configTree: any, domTree: any = dom.create.objectType([]), generateType: boolean = false) => {
    for (const key of Object.keys(configTree)) {
        const val = configTree[key];
        let flags = dom.DeclarationFlags.Optional;
        if (check(val, Object)) {
            let { type, constraints, mapping } = val;
            if (constraints) {
                if (contains(constraints, 'string')) {
                    type = 'string';
                } else if (contains(constraints, 'boolean')) {
                    type = 'boolean';
                } else if (contains(constraints, 'number')) {
                    type = 'number';
                } else if (contains(constraints, 'date')) {
                    type = 'date';
                } else {
                    type = 'any'
                };
                if (contains(constraints, 'required')) {
                    flags ^= dom.DeclarationFlags.Optional;
                }
            }
            if (type) {
                if (generateType) {
                    domTree.members.push(dom.create.property(key, type, flags));
                } else {
                    const next = dom.create.objectType([]);
                    domTree.members.push(dom.create.property(key, next));
                    recur(val, next, generateType);
                }
            } else {
                delete val['mapping'];
                delete val['constraints'];
                const next = dom.create.objectType([]);
                domTree.members.push(dom.create.property(key, next));
                recur(val, next, generateType);
            }
        }
        else {
            if (generateType) {
                const type: dom.Type = <any>typeof val;
                domTree.members.push(dom.create.property(key, type));
            } else {
                domTree.members.push(dom.create.property(key, val));
            }
        }
    }
}

const indentWidth = 4;
function convertToText(obj: any, indent: number = indentWidth): string {
    const spaces = (num: number = indent) => {
        let str = '';
        for (let i = 0; i < num; i++) {
            str = str + ' ';
        }
        return str;
    }
    if (obj == undefined) {
        return String(obj);
    } else if (typeof (obj) == "object" && (obj.join == undefined)) {
        const proplines = [];
        for (const prop in obj) {
            if (obj.hasOwnProperty(prop))
                proplines.push(prop + ": " + convertToText(obj[prop], indent + indentWidth));
        };
        if (proplines.length) {
            const header = '{' + '\n' + spaces();
            const terminator = '\n' + spaces(indent - indentWidth) + '}';
            return header + proplines.join(',\n' + spaces()) + terminator;
        }
        else return '{}';
    } else if (typeof (obj) == "object" && !(obj.join == undefined)) {
        const proplines = [];
        for (const val of obj) {
            proplines.push(convertToText(val, indent + indentWidth));
        };
        if (proplines.length) {
            const header = '[' + '\n' + spaces();
            const terminator = '\n' + spaces(indent - indentWidth) + ']';
            return header + proplines.join(',\n' + spaces()) + terminator;
        }
        else return '[]';
    } else if (typeof (obj) == "function") {
        return obj.toString();
    } else {
        return JSON.stringify(obj);
    }
}

export const createForm = ({ tree, namespace }: Options) => {
    // const ns = dom.create.namespace(namespace[0].toUpperCase() + namespace.slice(1));
    // ns.flags = dom.DeclarationFlags.Export;

    const intf = dom.create.interface('Document', dom.DeclarationFlags.Export);
    recur(clone(tree), intf, true);
    // ns.members.push(intf);

    intf.jsDocComment = 'generated by js-moss';

    const def = dom.emit(intf);
    return def + '\nexport const Schema = ' + convertToText(clone(tree));
}

export const createDts = ({ tree, namespace }: Options) => {
    const intf = dom.create.interface(namespace[0].toUpperCase() + namespace.slice(1));
    recur(clone(tree), intf, true);

    const ns = dom.create.namespace('Moss');
    ns.jsDocComment = 'generated by js-moss';
    ns.members.push(intf);

    return dom.emit(ns);
}